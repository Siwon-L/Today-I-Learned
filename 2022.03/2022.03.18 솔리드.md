# 학습내용
- SOLID
    - [위키 백과](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))

## 솔리드

### 솔리드란?
> 객체 지향 프로그램밍 설계 5가지 원칙

솔리드는 객체지향을 이용하여 프로그램을 만들 때 확장성과 코드의 재사용성을 높이기 위해 지켜야 할 원칙이다. 원칙이라고 무조건 지켜야 하는 것은 아니다. 원칙을 지켜가며 프로그래밍할 경우 위 같은 이점을 얻을 수 있지만, 그만큼 설계 및 초기 개발에 시간과 비용을 많이 투자해야 한다. 때문에 상황에 맞게 그때그때 필요한 원칙만 지켜가며 프로그래밍하는 것이 바람직하다.

### S: SRP(단일 책임의 원칙)
> 하나의 객체(타입)는 하나의 책임을 가져야 한다.

핵심 키워드는 
`캡슐화`, `은닉화`
객체(타입)는 하나의 역할만 해야 하며, 객체가 제공하는 기능은 모두 그 역할에 부합하는 기능만을 제공해야 한다. 또한, 캡슐화를 통해 외부에서 객체 내부를 직접 건드리지 못하도록 해야 한다.

### O: OCP(개방-폐쇠의 원칙)
> 객체(타입) 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

핵심 키워드는
`추상화`, `의존성`, `재사용성`

즉, 유지 보수에 있어, 기능을 추가하려 할 때 코드를 추가하되, 기존 코드는 변경돼서는 안된다.
때문에, 객체가 먼저 SRP 원칙을 준수해야 한다. 왜냐하면, 책임이 분산되어 있으면 무슨 객체에 코드를 추가할지 기준이 모호해지고, 객체 간 의존하고 있을 가능성이 높아 한 객체에 코드를 추가하면 의존하고 있는 객체들 또한 문제가 발생한다. 때문에 불가피하게 문제를 해결하기 위해 변경이 생길 수 있다. 또한, 위와 같은 이유로 SRP 원칙을 준수하더라도, 객체 간 결합도가 높아도 안된다. 때문에 인터페이스가 필요하고, Swift에선 이를 프로토콜로 인터페이스를 대신할 수 있다.

❓**인터페이스**란, 
서로 다른 두 무언가가 서로 소통함에 있어 약속 또는, 연결해 주는 매개체이다.
예를 들어, 컴퓨터와 키보드를 연 겨 해주는 USB 단자는 인터페이스에 해당한다. 이처럼 프로그래밍에서 인터페이스란, 서로 다른 두 객체를 간접적으로 연결해 주는 매개체이다.
두 객체 간 인터페이스를 두지 않고 연결시키면, 두 객체는 하나와 같다. 하나의 객체가 문제가 생기면, 다른 한 객체 또한, 문제가 생기고 때문에 재사용성이 떨어진다. 하지만, 인터페이스를 사용하면, 두 객체가 간접적으로 연결되어 있기 때문에, 하나의 객체에서 문제가 생겨도, 다른 한 객체 또한 문제가 생기는 것을 방지할 수 있다.
인터페이스는 추상화를 통해 만들어진다.

### L: LSP(리스코프 치환 원칙)
> 자식클래스는 부모 클래스로써의 역할을 완벽히 할 수 있어야한다.

핵심 키워드는
`상속`, `추상화`

위 원칙은 상속에 대한 원칙이다. 위 원칙을 지키기 위해선, 상속은 확장의 의미로만 사용되어야 위 원칙을 준수할 수 있다. 자식이 부모를 상속을 받아 `override`를 하게 되는 순간 위 원칙은 깨져버린다. 왜냐하면, 기능이 수정되기 때문에, 그때부터 자식은 부모의 자리를 대신할 수 없다. 때문에 상속은 확장에 의미로 사용되어야 하고, `override`를 사용해야 하는 경우 상속보다는 두 객체를 추상화하는 프로토콜을 만들어 채택하는 방법이 바람직하다. 또한 상속은 매우 높은 결합도를 가진다.

### I: ISP(인터페이스 분리 원칙)
> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

핵심 키워드는
`상속`, `추상화`

이 말은 즉, 객체 내부엔 사용되는 함수만 존재해야 한다는 말이다.
처음엔 "당연한 거 아닌가? 사용되는 메서드만 구현되어 있어야지."라는 생각이 들었다. 하지만, 생각해 보면, 상속을 받거나 프로토콜(인터페이스)을 채택을 하면, 사용하지 않지만, 상속을 받아 부모에게 물려받은 메서드 또는 프로토콜을 채택하면, 사용하지 않지만, 구현해야 하는 메서드가 생길 수 있다. 이 문제는 상속을 받아 부모의 기능을 일부만 사용하거나, 프로토콜이 요구하는 것이 많아 발생한다. 이는 프로토콜을 작은 단위로 분리하여 해결할 수 있다. 큰 덩어리의 프로토콜을 구체적이고 작은 단위들로 분리시킴으로써 객체들이 꼭 필요한 메서드들만 이용할 수 있게 한다.

### D: DIP(의존관계 역전 원칙)
> 추상화에 의존해야지, 구체화에 의존하면 안된다.

핵심 키워드는
`추상화`

이 말은 즉, 객체가 의존을 하려면, 중간에 추상화된 객체를 사이에 두고 의존하라는 뜻이다.
이전 원칙들을 지키려고 하게 되면 기본적으로 지킬 수밖에 없는 원칙이다.

## SOLID를 공부하며 느낀점
솔리드를 공부하며 느낀 것은,
솔리드 원칙은 의존성을 강조하고 있다. 사실 5가지 원칙 모두 의존성에 대한 이야기를 하고 있다. 유지 보수와 확장, 재사용성에 있어 의존성 즉, 결합 도는 매우 중요하다. 특정 객체가 다양한 곳에서 활용되려면, 철저하게 독립되어 있어야 한다. 그때 필요한 게 결합 도는 낮춰야 하고, 응집도가 높여야 한다. 그것을 도와주는 것이 인터페이스이고 Swift에선 프로토콜이 인터페이스의 역할을 어느 정도 수행한다. 때문에, 솔리드를 배우면, 프로토콜 만능설을 얘기한다고 한다. 프로토콜을 사용하면 확실하게 객체 간 분리를 도와준다. 하지만 가장 먼저 말했듯 프로토콜이 항상 옳은 것은 아니다. 일일이 프로토콜을 만든다는 것은 비용이 늘어나고, 코드의 양이 늘어난다. 때문에 어떠한 기능적 부분이 유연해야 하고, 확장이 많이 일어날 것인지 기획 단계에서 파악하고, 상황에 맞게 사용하는 것이 매우 베스트하다.
