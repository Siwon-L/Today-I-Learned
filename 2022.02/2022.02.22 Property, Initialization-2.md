## 학습내용
- Property
- Initialization-2

### Property

> 프로퍼티란?

프로퍼티란 한만디로, 타입의 속성

**프로퍼티 5가지 개념**
- 저장 프로퍼티(Stored Properties)
    - 변수 또는, 상수로 선언하고 값을 저장하는 프로퍼티
- 연산 프로퍼티(Computed Properties)
    - 계산의 의미를 가지고 있는 프로퍼티
- 지연 저장 프로퍼티(Lazy Stroed Properties)
    - 최초로 사용되는 순간에 초기값이 설정되는 프로퍼티
- 프로퍼티 감시자(Property Observers)
    - 저장 프로퍼티의 값이 변경되는 직전과 직후에 호출되며, 변경전 값, 후 값을 매개변수로 가지고 있다.
- 타입 프로퍼티(Type Properties)
    - 인스턴스로 접근이 불가하고 타입 자체에서만 접근이 가능한 프로퍼티

### 위 개념 중 저장 프로퍼티에 대한 특징
>- 저장 프로퍼티
>- 지연 저장 프로퍼티
 
### 저장 프로퍼티
**저장 프로퍼티**는 구조체, 클래스에서 다른 특징을 보인다. 이유는 **구조체와 클래스의 타입이 다르기 때문**이다.

먼저, 구조체는 값 타입이기 때문에 타입 저장 프로퍼티가 ```var```여도 인스턴스가 ```let``` 이면 내부 값을 수정할 수 없다.
하지만, 클래스는 참조 타입이기 때문에 인스턴스 타입과 상관없이 ```var```로 선언된 저장 프로퍼티는 수정이 가능하다.

### 지연 저장 프로퍼티
`lazy`키워드를 `var` 앞에 붙인다.
지연 저장 프로퍼티는 최초로 사용될 때까지 초깃값이 설정되지 않는다. 지연 저장 프로퍼티는 인스턴스 초기화가 이루어진 이후에도 값이 없을 가능성이 충분하기 때문에 `var`에만 사용될 수 있다. `let` 프로퍼티는 초기화 전에 초깃값을 미리 가지고 있어야 하기 때문에 `lazy`키워드를 사용할 수 없다.

> 지연 저장 프로퍼티는 초깃값이 미리 정해지지 않은 경우나, 초깃값이 변경될 수 있을 때 유용하다. 또한, 사용 전까지 초깃값이 설정되면 안 되는 복잡하거나, 계산 비용이 많이 드는 경우에도 유용함.

### Initialization-2

> 초기화란?

인스턴스에 클래스, 구조체, 열거형을 사용하기 위한 준비 단계

### 초기화 두 가지 방법에 대한 적절한 사용
타입 프로퍼티가 항상 같은 값을 가진다면, 초기화 구문 사용보다는 **기본 프로퍼티**를 사용하는 것이 바람직하다. 왜 내하면, 기본 프로퍼티를 사용하였을 때 코드가 간결하지고 명확해지며, 프로퍼티 타입을 유추하기 쉽다.
하지만, 인스턴스마다 다른 프로퍼티 초깃값을 설정해 줘야 하는 경우, 초깃값을 매개변수로 받을 수 있는 **초기화 구문**사용이 유용하다.

### 초기화 단계
스위프트에선 초기화는 2단계로 진행되는데 1단계가 끝나기 전까지 self를 이용하여 값을 참조하거나 프로퍼티, 메서드 등을 호출할 수 없음.

1단계 4

- 클래스에서 init()이 호출
- 새 인스턴스가 메모리에 할당된다. 하지만, 메모리는 초기화 되는 않은 상태
- init()내부 값은 클래스에 의해 저장될 프로퍼티의 값이 있음을 확인한다.(init이 호출되면, 클래스 내부 프로퍼티를 초기화 한다.)
- 자식에서 init을 호출하면 부모의 init이 호출된다.
- 가장 부모 클래스의 모든 프로퍼티에 값이 있음이 확인되면 1단계를 종료한다.

2단계

- 최 상단의 부모 클래스에서 다시 자식 클래스로 내려오며, 클래스 내부에서 self를 사용할 수 있으며, 프로퍼티를 수정하고 메서드를 호출할 수 있다.



## 궁금 했던 부분
Initialization-1에서 
```swift
class P {
    let name: String
    let subName: String

    init() {
        name = "사파리"
        subName = name
    }
}
```
가 가능 했던 이유


## 나름의 해답
위에 해답은 명확하게 찾지 못했지만, 다름의 두가지 가설을 새워 보았다.


- 가설 1
    - 초기화는 2단계로 이루어지는데 1단계가 끝나는 시점에서 `self`키워드를 사용이 가능하다. 하지만, `init()`이 호출되면, 값을 초기화하여 `init()`내부에서는 `self`가 가능하여 위 코드가 가능하다.

- 가설 2
    - 함수가 실행될 때는 위에서부터 절차적으로 실행되기 때문에 위에서 입력한 값을 밑에서 읽어올 수 있지만, 타입 내부가 초기화될 땐, 동시에 이루어지기 때문에 위에서 쓰고 밑에서 읽을 수 없다. 하지만 `lazy`를 이용하면, 순서가 생겨 가능해지고, `init()`내부에선 메서드와 같은 실행 방식을 가지고 있어 위에서 쓰고 밑에서 읽어오기 가능하다.

